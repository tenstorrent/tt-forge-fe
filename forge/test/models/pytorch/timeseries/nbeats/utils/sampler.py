# SPDX-FileCopyrightText: © 2024 Tenstorrent AI ULC

# SPDX-License-Identifier: Apache-2.0
"""
# code apapted from :
# https://github.com/ServiceNow/N-BEATS.git

This source code is provided for the purposes of scientific reproducibility
under the following limited license from Element AI Inc. The code is an
implementation of the N-BEATS model (Oreshkin et al., N-BEATS: Neural basis
expansion analysis for interpretable time series forecasting,
https://arxiv.org/abs/1905.10437). The copyright to the source code is licensed
under the Creative Commons - Attribution-NonCommercial 4.0 International license
(CC BY-NC 4.0): https://creativecommons.org/licenses/by-nc/4.0/.  Any commercial
use (whether for the benefit of third parties or internally in production)
requires an explicit license. The subject-matter of the N-BEATS model and
associated materials are the property of Element AI Inc. and may be subject to
patent protection. No license to patents is granted hereunder (whether express
or implied). Copyright © 2020 Element AI Inc. All rights reserved.

"""

"""
Timeseries sampler
"""

import numpy as np


class TimeseriesSampler:
    def __init__(
        self,
        timeseries: np.ndarray,
        insample_size: int,
        outsample_size: int,
        window_sampling_limit: int,
        batch_size: int = 1024,
    ):
        """
        Timeseries sampler.

        :param timeseries: Timeseries data to sample from. Shape: timeseries, timesteps
        :param insample_size: Insample window size. If timeseries is shorter then it will be 0-padded and masked.
        :param outsample_size: Outsample window size. If timeseries is shorter then it will be 0-padded and masked.
        :param window_sampling_limit: Size of history the sampler should use.
        :param batch_size: Number of sampled windows.
        """
        self.timeseries = [ts for ts in timeseries]
        self.window_sampling_limit = window_sampling_limit
        self.batch_size = batch_size
        self.insample_size = insample_size
        self.outsample_size = outsample_size

    def __iter__(self):
        """
        Batches of sampled windows.

        :return: Batches of:
         Insample: "batch size, insample size"
         Insample mask: "batch size, insample size"
         Outsample: "batch size, outsample size"
         Outsample mask: "batch size, outsample size"
        """
        while True:
            insample = np.zeros((self.batch_size, self.insample_size))
            insample_mask = np.zeros((self.batch_size, self.insample_size))
            outsample = np.zeros((self.batch_size, self.outsample_size))
            outsample_mask = np.zeros((self.batch_size, self.outsample_size))
            sampled_ts_indices = np.random.randint(len(self.timeseries), size=self.batch_size)
            for i, sampled_index in enumerate(sampled_ts_indices):
                sampled_timeseries = self.timeseries[sampled_index]
                cut_point = np.random.randint(
                    low=max(1, len(sampled_timeseries) - self.window_sampling_limit),
                    high=len(sampled_timeseries),
                    size=1,
                )[0]

                insample_window = sampled_timeseries[max(0, cut_point - self.insample_size) : cut_point]
                insample[i, -len(insample_window) :] = insample_window
                insample_mask[i, -len(insample_window) :] = 1.0
                outsample_window = sampled_timeseries[
                    cut_point : min(len(sampled_timeseries), cut_point + self.outsample_size)
                ]
                outsample[i, : len(outsample_window)] = outsample_window
                outsample_mask[i, : len(outsample_window)] = 1.0
            yield insample, insample_mask, outsample, outsample_mask
